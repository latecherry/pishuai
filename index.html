<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="viewport-fit" content="cover" />
  <title>Gyro Swim Runner</title>
  <style>
    :root{
      --bg:#021e2f;
      --ui:#e9f2f9;
      --accent:#3fd0ff;
      --gold:#ffd166;
      --panel-bg:#001826ee;
      --panel-border:#ffffff2b;
      --panel-shadow:#000a;
      --glass-bg:#0006;
      --danger:#ff4d6d;
      --rock:#6f8a99;
      --shield:#7fdcff;
    }
    html,body{
      margin:0; padding:0; width:100%; height:100%; overflow:hidden;
      background:#000;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,'Noto Sans',sans-serif;
      -webkit-text-size-adjust:100%;
    }
    #wrap{
      position:fixed;
      left:0; top:0;
      width:100dvw; height:100dvh;
      background:url("assets/sea.png") center center / cover no-repeat;
    }
    #c{
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
      background:transparent;
    }
    #hud{
      position:fixed; left:0; right:0; top:0;
      display:flex; justify-content:space-between; gap:.5rem;
      padding:.6rem .8rem;
      color:var(--ui); font-weight:600;
      text-shadow:0 1px 2px #0009;
      pointer-events:none; z-index:10
    }
    .pill{
      background:var(--glass-bg);
      border:1px solid #fff2;
      border-radius:12px;
      padding:.25rem .5rem
    }
    #panel{
      position:fixed;left:50%;top:50%;
      transform:translate(-50%, -50%);
      width:min(520px,92vw);
      max-height:min(90vh,600px);
      overflow-y:auto;
      background:var(--panel-bg);
      border:1px solid var(--panel-border);
      border-radius:16px;
      color:var(--ui);
      padding:16px 16px 12px;
      box-shadow:0 10px 30px var(--panel-shadow);
      backdrop-filter:blur(6px);
      z-index:20
    }
    #panel h1{
      margin:.2rem 0 .6rem;
      font-size:1.35rem;
      color:var(--accent);
      line-height:1.25;
      display:flex;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    #panel p{line-height:1.35;margin:.35rem 0;color:var(--ui);}
    #panel .row{display:flex;gap:.6rem;flex-wrap:wrap;align-items:center}
    #panel label{font-size:.9rem;opacity:.9}
    #panel input[type=range]{width:160px}
    #panel button{
      appearance:none;border:0;border-radius:999px;
      padding:.65rem 1rem;font-weight:700;
      background:var(--accent);color:#05384c;
      cursor:pointer;
      box-shadow:0 8px 20px #00c8ff44
    }
    #panel small{opacity:.8}
    #leaderboardBox{
      background:#0004;
      border:1px solid #ffffff22;
      border-radius:12px;
      padding:.75rem .9rem .6rem;
      line-height:1.4;
      margin-top:1rem;
      box-shadow:0 8px 24px #0008;
    }
    .lb-title{
      font-size:.9rem;
      font-weight:600;
      color:var(--accent);
      text-shadow:0 1px 2px #000c;
      margin-bottom:.5rem;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .lb-title::after{
      content:"æœ¬æœºå‰ä¸‰å";
      font-size:.7rem;
      font-weight:500;
      color:#cfe8ffcc;
      background:#003044aa;
      border:1px solid #00e1ff55;
      border-radius:999px;
      padding:.15rem .5rem;
      line-height:1;
    }
    .lb-row{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      font-size:.9rem;
      font-weight:600;
      color:#fff;
      text-shadow:0 1px 2px #000a;
      margin-bottom:.4rem;
    }
    .lb-mode{
      min-width:4.5rem;
      color:#fff;
      background:#ffffff18;
      border:1px solid #ffffff33;
      border-radius:8px;
      padding:.2rem .5rem;
      font-size:.8rem;
      font-weight:600;
      line-height:1.2;
      text-align:center;
    }
    .lb-scores{
      flex:1;
      text-align:right;
      color:#ffd166;
      font-variant-numeric:tabular-nums;
    }
    .lb-hint{
      font-size:.7rem;
      line-height:1.3;
      color:#cfe8ff99;
      text-align:right;
      margin-top:.2rem;
      font-weight:400;
    }
    #howtoBox{
      background:#0004;
      border:1px solid #ffffff22;
      border-radius:12px;
      padding:.9rem .9rem .6rem;
      line-height:1.4;
      margin-top:1rem;
      box-shadow:0 8px 24px #0008;
      color:var(--ui);
      font-size:.85rem;
    }
    #howtoBoxTitle{
      font-size:.9rem;
      font-weight:600;
      color:var(--accent);
      text-shadow:0 1px 2px #000c;
      margin-bottom:.6rem;
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      flex-wrap:wrap;
      row-gap:.4rem;
    }
    #howtoBoxTitle span:last-child{
      font-size:.7rem;
      font-weight:500;
      color:#cfe8ffcc;
      background:#003044aa;
      border:1px solid #00e1ff55;
      border-radius:999px;
      padding:.15rem .5rem;
      line-height:1;
    }
    .howtoColumns{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:1rem .8rem;
    }
    .colBlockTitle{
      font-size:.8rem;
      font-weight:600;
      color:#fff;
      text-shadow:0 1px 2px #000;
      border-left:3px solid var(--accent);
      padding-left:.5rem;
      margin-bottom:.5rem;
      line-height:1.2;
      display:flex;
      align-items:center;
      gap:.4rem;
    }
    .colBlockTitle.good .dot{
      background:var(--shield);
      border-color:#ffffff66;
    }
    .colBlockTitle.bad .dot{
      background:var(--danger);
      border-color:#ffffff66;
    }
    .colBlockTitle .dot{
      width:.6rem;
      height:.6rem;
      border-radius:4px;
      border:1px solid;
      box-shadow:0 0 6px #000a;
    }
    .infoList{
      display:flex;
      flex-direction:column;
      gap:.6rem;
    }
    .infoCard{
      background:#ffffff08;
      border:1px solid #ffffff22;
      border-radius:10px;
      padding:.5rem .6rem .55rem;
      box-shadow:0 6px 16px #000a;
      min-height:4.5rem;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
      position:relative;
    }
    .infoHead{
      font-size:.8rem;
      font-weight:600;
      line-height:1.2;
      display:flex;
      align-items:center;
      gap:.4rem;
      color:#fff;
      text-shadow:0 1px 2px #000;
      margin-bottom:.4rem;
    }
    .tagIcon{
      width:.7rem;
      height:.7rem;
      border-radius:4px;
      border:1px solid #ffffff66;
      box-shadow:0 0 6px #000a;
    }
    .tagCoin   { background:var(--gold); color:#000; }
    .tagHeart  { background:var(--danger); }
    .tagShield { background:var(--shield); }
    .tagMine   { background:var(--danger); }
    .tagRock   { background:var(--rock); }
    .infoBody{
      font-size:.75rem;
      line-height:1.3;
      color:#cfe8ffdd;
      text-shadow:0 1px 2px #000;
      font-weight:400;
    }
    #tips{
      position:fixed;
      left:50%;transform:translateX(-50%);
      color:#cfe8ff;opacity:.85;
      font-size:.9rem;
      text-shadow:0 1px 2px #0009;
      z-index:5;
      bottom:calc(10px + env(safe-area-inset-bottom,0px));
    }
    #toast{
      position:fixed;
      left:50%;top:14%;
      transform:translateX(-50%);
      padding:.4rem .8rem;
      background:#0008;
      color:#fff;
      border:1px solid #ffffff24;
      border-radius:12px;
      display:none;
      z-index:15;
      font-weight:500;
      text-shadow:0 1px 2px #000;
    }
    #pauseOverlay{
      position:fixed;inset:0;
      background:#00000080;
      display:none;
      place-items:center;
      color:#fff;
      z-index:25
    }
    #pauseOverlay .box{
      background:#072235;
      border:1px solid #ffffff2b;
      border-radius:16px;
      padding:16px 20px;
      text-align:center;
      box-shadow:0 10px 30px #000a;
    }
    #pauseOverlay button{margin-top:10px}
    .floating{
      position:fixed;
      right:10px;
      display:flex;
      gap:.5rem;
      z-index:10;
      bottom:calc(10px + env(safe-area-inset-bottom,0px));
    }
    .ghostBtn{
      appearance:none;
      border:1px solid #ffffff4d;
      background:#0005;
      color:#ddf;
      border-radius:999px;
      padding:.55rem .8rem;
      font-weight:700;
      box-shadow:0 6px 20px #000a;
      cursor:pointer;
    }
    @supports (padding: env(safe-area-inset-top)){
      #hud{padding-top:calc(.6rem + env(safe-area-inset-top));}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c" aria-label="Gyro Swim Runner game canvas"></canvas>
  </div>
  <div id="hud">
    <div class="pill">åˆ†æ•° <span id="score">0</span></div>
    <div class="pill">é€Ÿåº¦ <span id="spd">0.0</span> m/s</div>
    <div class="pill">å‰©ä½™ç”Ÿå‘½ <span id="hp">3</span></div>
  </div>
  <div id="panel" role="dialog" aria-modal="true">
    <h1 id="panelTitle">
      <span>Gyro Swim Runner Â· æ¸¸æ³³é™€èºä»ªè·‘é…·</span>
    </h1>
    <p id="panelDesc">
      æŒ‰<strong>å¼€å§‹</strong>åï¼Œè‹¥æ˜¯ iOS è®¾å¤‡ä¼šå¼¹å‡ºâ€œå…è®¸è¿åŠ¨è®¿é—®â€çš„å¯¹è¯æ¡†ï¼Œè¯·é€‰æ‹©å…è®¸ã€‚<br>
      å·¦å³å€¾æ–œæ§åˆ¶æ°´å¹³ç§»åŠ¨ï¼›å‰åå€¾æ–œæ§åˆ¶ä¸Š/ä¸‹æµ®ï¼›é•¿æŒ‰å±å¹•å†²åˆºã€‚
    </p>
    <div class="row" style="margin:.5rem 0 .25rem">
      <label>çµæ•åº¦</label>
      <input id="sens" type="range" min="0.2" max="3" step="0.1" value="1.3" />
      <label>éš¾åº¦</label>
      <select id="difficulty">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
    </div>
    <div class="row" style="gap:1rem;margin-top:.6rem">
      <button id="startBtn">å¼€å§‹æ¸¸æˆ</button>
      <button id="calBtn" class="ghostBtn" style="border-radius:12px">æ ¡å‡†æ°´å¹³</button>
      <small>ï¼ˆå°†æ‰‹æœºä¿æŒä½ è§‰å¾—çš„â€œæ°´å¹³â€å§¿æ€åç‚¹æ ¡å‡†ï¼‰</small>
    </div>
    <p style="margin-top:.6rem">
      <small>è°ƒè¯•ï¼šæ¡Œé¢å¯ç”¨ â† â†’ â†‘ â†“ æ§åˆ¶ï¼›<kbd>P</kbd> æš‚åœï¼›<kbd>R</kbd> å¤ä½ã€‚</small>
    </p>
    <div id="howtoBox">
      <div id="howtoBoxTitle">
        <span>ç©æ³•è¯´æ˜ / é“å…·ä¸å±é™©</span>
        <span>å·¦è¾¹æ‹¿ï¼Œå³è¾¹èº² ğŸ˜</span>
      </div>
      <div class="howtoColumns">
        <div>
          <div class="colBlockTitle good">
            <div class="dot"></div>
            <div>å¢ç›Šé“å…·</div>
          </div>
          <div class="infoList">
            <div class="infoCard">
              <div class="infoHead">
                <div class="tagIcon tagCoin"></div>
                <div>é‡‘å¸</div>
              </div>
              <div class="infoBody">
                åƒåˆ°å +10 åˆ†ã€‚åˆ†æ•°ä¼šè¿›å…¥æœ¬æœºæ’è¡Œæ¦œï¼ˆæŒ‰éš¾åº¦åˆ†åˆ«è®°å½•ï¼‰ã€‚
              </div>
            </div>
            <div class="infoCard">
              <div class="infoHead">
                <div class="tagIcon tagHeart"></div>
                <div>çˆ±å¿ƒ</div>
              </div>
              <div class="infoBody">
                å›å¤ 1 æ»´è¡€ï¼›å¦‚æœè¡€é‡å·²æ»¡ï¼Œæ”¹ä¸º +5 åˆ†ã€‚åƒåˆ°ä¼šå‡ºç°ç²‰è‰²æŸ”å…‰æ•ˆæœã€‚
              </div>
            </div>
            <div class="infoCard">
              <div class="infoHead">
                <div class="tagIcon tagShield"></div>
                <div>æŠ¤ç›¾</div>
              </div>
              <div class="infoBody">
                è·å¾—ä¸€å±‚è“è‰²æŠ¤ç›¾çƒã€‚æŠ¤ç›¾æŒç»­çº¦ 10 ç§’ï¼›åœ¨æ­¤æœŸé—´ï¼Œç¬¬ä¸€æ¬¡æ’åˆ°éšœç¢ç‰©ä¼šè¢«å®Œå…¨æŠµæ¶ˆï¼Œä¸æ‰£è¡€ï¼Œç„¶åæŠ¤ç›¾ç«‹åˆ»æ¶ˆå¤±ã€‚
              </div>
            </div>
          </div>
        </div>
        <div>
          <div class="colBlockTitle bad">
            <div class="dot"></div>
            <div>å±é™©éšœç¢</div>
          </div>
          <div class="infoList">
            <div class="infoCard">
              <div class="infoHead">
                <div class="tagIcon tagMine"></div>
                <div>é²¨é±¼</div>
              </div>
              <div class="infoBody">
                æ’åˆ°ä¼šæ‰è¡€ï¼šEasy / Normal æ‰ 1 æ»´è¡€ï¼ŒHard æ‰ 2 æ»´è¡€ã€‚<br>
                å¦‚æœä½ å½“å‰æœ‰æŠ¤ç›¾ï¼Œåˆ™ä¼˜å…ˆæ¶ˆè€—æŠ¤ç›¾ï¼Œä¸æ‰è¡€ã€‚
              </div>
            </div>
            <div class="infoCard">
              <div class="infoHead">
                <div class="tagIcon tagRock"></div>
                <div>å‰‘é±¼</div>
              </div>
              <div class="infoBody">
                ä¹Ÿæ˜¯å±é™©éšœç¢ï¼Œä¼šé€ æˆä¼¤å®³ã€‚ä¹Ÿèƒ½è¢«æŠ¤ç›¾æŠµæŒ¡ã€‚
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="leaderboardBox"></div>
  </div>
  <div id="pauseOverlay">
    <div class="box">
      <div style="font-size:1.2rem;margin-bottom:.4rem">å·²æš‚åœ</div>
      <button class="ghostBtn" id="resumeBtn">ç»§ç»­</button>
    </div>
  </div>
  <div id="tips">æç¤ºï¼šè‹¥æ— ååº”ï¼Œè¯·åœ¨ç³»ç»Ÿè®¾ç½®é‡Œå¼€å¯â€œè¿åŠ¨ä¸ä½“èƒ½è®¿é—®æƒé™â€ã€‚</div>
  <div id="toast"></div>
  <div class="floating">
    <button id="pauseBtn" class="ghostBtn">æš‚åœ</button>
    <button id="restartBtn" class="ghostBtn">é‡å¼€</button>
  </div>
  <script>
  ;(() => {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const spdEl = document.getElementById('spd');
    const hpEl = document.getElementById('hp');
    const panel = document.getElementById('panel');
    the_panelTitleEl = document.getElementById('panelTitle'); // ä¿æŒåŸå†™æ³•
    const panelTitleEl = the_panelTitleEl;
    const panelDescEl = document.getElementById('panelDesc');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resumeBtn = document.getElementById('resumeBtn');
    const restartBtn = document.getElementById('restartBtn');
    const calBtn = document.getElementById('calBtn');
    const sensSlider = document.getElementById('sens');
    const diffSel = document.getElementById('difficulty');
    const toast = document.getElementById('toast');
    const leaderboardBox = document.getElementById('leaderboardBox');

    let W = 0, H = 0, dpr = 1;

    function fitToViewport(){
      const vw = window.visualViewport?.width || window.innerWidth;
      const vh = window.visualViewport?.height || window.innerHeight;
      document.getElementById('wrap').style.width = vw + 'px';
      document.getElementById('wrap').style.height = vh + 'px';
      W = Math.max(320, Math.floor(vw));
      H = Math.max(320, Math.floor(vh));
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(W * dpr);
      canvas.height = Math.floor(H * dpr);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    fitToViewport();
    window.addEventListener('resize', fitToViewport, {passive:true});
    window.visualViewport?.addEventListener('resize', fitToViewport, {passive:true});

    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const rand = (a,b)=>a + Math.random()*(b-a);

    function showToast(msg, ms=1400){
      toast.textContent = msg;
      toast.style.display='block';
      clearTimeout(showToast.tid);
      showToast.tid = setTimeout(()=>toast.style.display='none', ms);
    }

    function loadScores(mode){
      try{
        const raw = localStorage.getItem('scores_'+mode);
        if(!raw) return [];
        const arr = JSON.parse(raw);
        if(!Array.isArray(arr)) return [];
        return arr;
      }catch(e){
        return [];
      }
    }
    function saveScore(mode, score){
      if(!mode) return;
      const entry = {
        score: Math.floor(score),
        time: Date.now()
      };
      const arr = loadScores(mode);
      arr.push(entry);
      arr.sort((a,b)=>b.score-a.score);
      const top3 = arr.slice(0,3);
      try{
        localStorage.setItem('scores_'+mode, JSON.stringify(top3));
      }catch(e){}
    }

    function formatRow(label, arr){
      const s1 = arr[0]?.score ?? 'â€”';
      const s2 = arr[1]?.score ?? 'â€”';
      const s3 = arr[2]?.score ?? 'â€”';
      return `
        <div class="lb-row">
          <span class="lb-mode">${label}</span>
          <span class="lb-scores">${s1} / ${s2} / ${s3}</span>
        </div>`;
    }

    function renderLeaderboardPanel(){
      const easy   = loadScores('easy');
      const normal = loadScores('normal');
      const hard   = loadScores('hard');
      const html = `
        <div class="lb-title">æœ¬æœºæœ€é«˜åˆ†</div>
        ${formatRow('Easy',   easy)}
        ${formatRow('Normal', normal)}
        ${formatRow('Hard',   hard)}
        <div class="lb-hint">ï¼ˆåªè®°å½•å‰ä¸‰åï¼Œä¿å­˜åœ¨æœ¬è®¾å¤‡ï¼‰</div>
      `;
      leaderboardBox.innerHTML = html;
    }

    // èµ„æºå›¾ç‰‡
    const coinImg = new Image();
    coinImg.src = 'assets/coin.svg';
    const heartImg = new Image();
    heartImg.src = 'assets/heart.svg';
    const shieldImg = new Image();
    shieldImg.src = 'assets/shield.svg';
    const sharkImg = new Image();
    sharkImg.src = 'assets/shark.png';
    const swordfishImg = new Image();
    swordfishImg.src = 'assets/swordfish.png';

    // å…¨å±€çŠ¶æ€
    const State = {
      init(){
        this.reset();
        this.running=false;
        this.paused=false;
        this.device={alpha:0,beta:0,gamma:0, calib:{beta:0,gamma:0}, sens: parseFloat(sensSlider.value)};
        this.input={ax:0,ay:0,sprint:false};
        this.time={now:0,last:0,dt:0};
        this.shake = { t:0, mag:0 };
        this.runDifficulty = diffSel.value;
        this.fx = {
          particles: [],
          pulse: 0,
          pulseMax: 0.3,
          flash: 0,
          flashMax: 0.15
        };
      },
      reset(){
        const diff = diffSel.value;
        const diffCfg = {
          easy:   { baseSpeed:4,  maxSpeed:8.5,  spawn:1.1,  damage:1, heartRate:[12,18], sharkProb:0.15 },
          normal: { baseSpeed:5,  maxSpeed:10.5, spawn:0.95, damage:1, heartRate:[16,24], sharkProb:0.30 },
          hard:   { baseSpeed:6,  maxSpeed:12.5, spawn:0.85, damage:2, heartRate:[22,30], sharkProb:0.50 }
        }[diff];

        const laneW = clamp(Math.round(W/9), 90, 140);
        const padding = clamp(Math.round(W*0.06), 32, 80);
        const lanes = clamp(Math.floor((W - 2*padding)/laneW), 5, 11);

        const shieldRateRange = [
          diffCfg.heartRate[0]*0.6,
          diffCfg.heartRate[1]*0.6
        ];

        this.cfg = Object.assign({
          laneWidth: laneW,
          lanes,
          worldPadding: padding,
          swimAccel: 18,
          swimDamp:0.90,
          gravity:0,
          sprintBoost:1.8,
          bubbleRate:60,
          coinRate:2.2,
          obstacleRate: diffCfg.spawn,
          hurtCooldown:0.9,
          hpMax:5,
          heartRateRange: diffCfg.heartRate,
          shieldRateRange: shieldRateRange,
          shieldDuration: 10.0,
          sharkProb: diffCfg.sharkProb
        }, diffCfg);

        this.world = { z:0, speed:this.cfg.baseSpeed, t:0 };

        this.hero = {
          x:W/2, y:H/2,
          vx:0, vy:0,
          r:Math.max(14, Math.min(20, Math.round(Math.min(W,H)/30))),
          hp:3,
          invul:0,
          score:0,
          shieldTime:0
        };

        this.obs=[];
        this.coins=[];
        this.bubbles=[];
        this.hearts=[];
        this.shields=[];

        this.spawnTick=0;
        this.coinTick=0;
        this.bubbleTick=0;
        this.heartTick=rand(this.cfg.heartRateRange[0], this.cfg.heartRateRange[1]) * 0.3;
        this.shieldTick=rand(this.cfg.shieldRateRange[0], this.cfg.shieldRateRange[1]) * 0.3;

        this.surviveTime=0;

        this.shake = { t:0, mag:0 };
        this.fx = {
          particles: [],
          pulse: 0,
          pulseMax: 0.3,
          flash: 0,
          flashMax: 0.15
        };
        this.runDifficulty = diffSel.value;
      }
    };
    State.init();

    function requestMotionPermission(){
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      if (isIOS && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
        DeviceMotionEvent.requestPermission().then(r1=>{
          if(r1!=='granted') throw new Error('æœªæˆæƒè¿åŠ¨ä¼ æ„Ÿå™¨');
          if (typeof DeviceOrientationEvent.requestPermission === 'function'){
            return DeviceOrientationEvent.requestPermission();
          }
        }).catch(e=>{
          showToast(e.message || 'éœ€è¦ä¼ æ„Ÿå™¨æƒé™');
        });
      }
    }

    function handleOrientation(e){
      const {beta, gamma} = e;
      const b0=State.device.calib.beta, g0=State.device.calib.gamma, sens=State.device.sens;
      const ax = clamp((gamma - g0) / 25, -1, 1) * sens;
      const ay = clamp(((beta - b0)) / 25, -1, 1) * sens;
      State.input.ax = clamp(ax, -1.5, 1.5);
      State.input.ay = clamp(ay, -1.5, 1.5);
    }
    function calibrate(){
      State.device.calib.beta = State.device.beta;
      State.device.calib.gamma = State.device.gamma;
      showToast('å·²æ ¡å‡†');
    }

    window.addEventListener('deviceorientation', (e)=>{
      State.device.alpha=e.alpha||0;
      State.device.beta=e.beta||0;
      State.device.gamma=e.gamma||0;
      handleOrientation(State.device);
    });

    // è§¦æ‘¸ / é”®ç›˜è¾“å…¥
    let touchId = null;
    canvas.addEventListener('touchstart',(e)=>{
      if (touchId===null){
        touchId=e.changedTouches[0].identifier;
        State.input.sprint=true;
      }
    }, {passive:true});

    canvas.addEventListener('touchend',(e)=>{
      for (const t of e.changedTouches){
        if (t.identifier===touchId){
          touchId=null;
          State.input.sprint=false;
        }
      }
    }, {passive:true});

    const keys = new Set();
    window.addEventListener('keydown', (e)=>{
      keys.add(e.key);
      if (e.key==='p'||e.key==='P'){ togglePause(); }
      if (e.key==='r'||e.key==='R'){ restart(); }
    });
    window.addEventListener('keyup', (e)=>{ keys.delete(e.key); });

    function keyboardInput(){
      const ax = (keys.has('ArrowRight')?1:0) - (keys.has('ArrowLeft')?1:0);
      const ay = (keys.has('ArrowDown')?1:0) - (keys.has('ArrowUp')?1:0);
      State.input.ax = ax * State.device.sens;
      State.input.ay = ay * State.device.sens;
      State.input.sprint = keys.has(' ');
    }

    // ç”Ÿæˆéšœç¢ç‰©ï¼ˆå«éšæœºå·¦å³ç¿»è½¬ + é™åˆ¶åˆ°ç©å®¶å¯è¾¾åŒºåŸŸï¼‰
    function spawnObstacle(){
      const w = rand(State.cfg.laneWidth*0.7, State.cfg.laneWidth*1.2);
      const h = rand(Math.max(24,H*0.04), Math.max(40,H*0.08));

      // é¿å¼€å·¦å³æ­»åŒºï¼šä½¿ç”¨ worldPadding
      const minX = State.cfg.worldPadding + w/2;
      const maxX = W - State.cfg.worldPadding - w/2;

      const x = rand(minX, maxX);
      const y = rand(h/2, H - h/2);

      const z = State.world.z + rand(H*1.1, H*2.0);
      const type = (Math.random() < State.cfg.sharkProb) ? 'shark' : 'swordfish';

      // éšæœºæ°´å¹³ç¿»è½¬
      const flip = (Math.random() < 0.5) ? 1 : -1;

      State.obs.push({x,y,z,w,h,type,hit:false,flip});
    }

    // ç”Ÿæˆé‡‘å¸ï¼ˆé™åˆ¶åˆ°ç©å®¶å¯è¾¾åŒºåŸŸï¼‰
    function spawnCoin(){
      const r = Math.max(9, Math.min(14, Math.round(Math.min(W,H)/50)));

      const minX = State.cfg.worldPadding + r;
      const maxX = W - State.cfg.worldPadding - r;

      const x = rand(minX, maxX);
      const y = rand(r, H - r);

      const z = State.world.z + rand(H*0.9, H*1.8);
      State.coins.push({
        x,y,z,
        r,
        got:false,
        floating:false,
        linger:0,
        fx:0,fy:0,fr:0,
        remove:false
      });
    }

    // ç”Ÿæˆçˆ±å¿ƒï¼ˆé™åˆ¶åˆ°ç©å®¶å¯è¾¾åŒºåŸŸï¼‰
    function spawnHeart(){
      const r = Math.max(11, Math.min(16, Math.round(Math.min(W,H)/46)));

      const minX = State.cfg.worldPadding + r;
      const maxX = W - State.cfg.worldPadding - r;

      const x = rand(minX, maxX);
      const y = rand(r, H - r);

      const z = State.world.z + rand(H*0.9, H*1.8);
      State.hearts.push({
        x,y,z,
        r,
        got:false,
        floating:false,
        linger:0,
        fx:0,fy:0,fr:0,
        remove:false
      });
    }

    // ç”ŸæˆæŠ¤ç›¾ï¼ˆé™åˆ¶åˆ°ç©å®¶å¯è¾¾åŒºåŸŸï¼‰
    function spawnShield(){
      const r = Math.max(11, Math.min(16, Math.round(Math.min(W,H)/46)));

      const minX = State.cfg.worldPadding + r;
      const maxX = W - State.cfg.worldPadding - r;

      const x = rand(minX, maxX);
      const y = rand(r, H - r);

      const z = State.world.z + rand(H*0.9, H*1.8);
      State.shields.push({
        x,y,z,
        r,
        got:false,
        floating:false,
        linger:0,
        fx:0,fy:0,fr:0,
        remove:false
      });
    }

    function spawnBubble(){
      const x = rand(20, W-20);
      const y = rand(H-30, H-10);
      State.bubbles.push({
        x,y,
        r:rand(2,5),
        vz:rand(-120,-60),
        life:rand(0.8,1.8)
      });
    }

    function aabbCircleOverlap(ax,ay,aw,ah,cx,cy,cr){
      const nx = clamp(cx, ax, ax+aw);
      const ny = clamp(cy, ay, ay+ah);
      const dx = cx - nx, dy = cy - ny;
      return (dx*dx + dy*dy) <= cr*cr;
    }

    function clearFrame(){
      ctx.clearRect(0,0,W,H);
    }

    function drawHero(h, t){
      const sway = Math.sin(t*8 + h.y*0.02) * 6;
      const x=h.x, y=h.y;

      // æŠ¤ç›¾å‘å…‰
      if (h.shieldTime > 0){
        const glowR = h.r + 18;
        ctx.save();
        ctx.globalAlpha = 0.35;
        const grd = ctx.createRadialGradient(x, y, 0, x, y, glowR);
        grd.addColorStop(0, 'rgba(120,200,255,0.8)');
        grd.addColorStop(1, 'rgba(120,200,255,0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(x, y, glowR, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = '#7fdcff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, glowR, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      // æ³¡æ³¡å°¾è¿¹
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#7fdcff';
      for(let i=0;i<4;i++){
        const bx = x - 22 - i*10 + Math.sin(t*10+i)*2;
        const by = y + Math.cos(t*8+i)*2;
        ctx.beginPath();
        ctx.arc(bx, by, 2+i*0.8, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // èº«ä½“
      ctx.fillStyle = '#73c6ff';
      ctx.beginPath();
      ctx.ellipse(x, y, 26, 12, 0, 0, Math.PI*2);
      ctx.fill();

      // å¤´
      ctx.fillStyle = '#ffd4a3';
      ctx.beginPath();
      ctx.arc(x+24, y-2, 7, 0, Math.PI*2);
      ctx.fill();

      // æŠ¤ç›®é•œ
      ctx.fillStyle = '#144d66';
      ctx.fillRect(x+18, y-6, 12, 8);
      ctx.fillStyle = '#8be0ff';
      ctx.fillRect(x+19, y-5, 10, 6);

      // æ‰‹è‡‚
      ctx.strokeStyle = '#73c6ff';
      ctx.lineWidth = 4;
      ctx.lineCap='round';
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x-18, y + sway*0.6);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x+6, y+2);
      ctx.lineTo(x-8, y - sway*0.6);
      ctx.stroke();

      // å—ä¼¤é—ªçƒ
      if (h.invul>0){
        ctx.globalAlpha = 0.5 + 0.5*Math.sin(t*30);
        ctx.fillStyle='#fff';
        ctx.beginPath();
        ctx.ellipse(x, y, 29, 15, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha=1;
      }
    }

    // ç»˜åˆ¶éšœç¢ç‰©ï¼ˆå¸¦æ°´å¹³ç¿»è½¬ï¼‰
    function drawObstacle(o, zRel){
      ctx.save();

      const par = clamp(1 - zRel/(H*2.0), 0, 1);
      const rx = o.x;
      const ry = o.y;
      const boxW = o.w * par;
      const boxH = o.h * par;

      if (o.type==='shark' || o.type==='swordfish'){
        const imgObj = (o.type==='shark') ? sharkImg : swordfishImg;
        const SCALE  = (o.type==='shark') ? 3.5 : 2.5;

        if (imgObj.complete && imgObj.naturalWidth){
          const iw = imgObj.naturalWidth;
          const ih = imgObj.naturalHeight;
          const imgRatio = iw / ih;
          const boxRatio = boxW / boxH;
          let drawW, drawH;
          if (boxRatio > imgRatio){
            drawH = boxH;
            drawW = drawH * imgRatio;
          }else{
            drawW = boxW;
            drawH = drawW / imgRatio;
          }
          drawW *= SCALE;
          drawH *= SCALE;

          // æ ¹æ® o.flip æ°´å¹³ç¿»è½¬
          const flipSign = (o.flip === -1) ? -1 : 1;

          ctx.save();
          ctx.translate(rx, ry);
          ctx.scale(flipSign, 1);
          ctx.drawImage(
            imgObj,
            -drawW/2,
            -drawH/2,
            drawW,
            drawH
          );
          ctx.restore();

        }else{
          if (o.type==='shark'){
            ctx.fillStyle = '#8a1f1f';
          }else{
            ctx.fillStyle = '#274e5f';
          }
          ctx.beginPath();
          ctx.ellipse(rx, ry, boxW*0.6, boxH*0.4, 0, 0, Math.PI*2);
          ctx.fill();
        }
      }else{
        ctx.fillStyle = '#ff00ff';
        ctx.beginPath();
        ctx.roundRect(rx-boxW/2, ry-boxH/2, boxW, boxH, 10);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawCoinDepth(c, zRel){
      if (!coinImg.complete || !coinImg.naturalWidth) return;
      ctx.save();
      const par = clamp(1 - zRel/(H*2.0), 0, 1);
      const rx = c.x;
      const ry = c.y;
      const r = c.r * (par*0.8+0.2);
      const s = r*2;
      ctx.drawImage(coinImg, rx - s/2, ry - s/2, s, s);
      ctx.restore();
    }

    function drawCoinFloating(c){
      if (!coinImg.complete || !coinImg.naturalWidth) return;
      ctx.save();
      const r = c.fr;
      const s = r*2;
      ctx.drawImage(coinImg, c.fx - s/2, c.fy - s/2, s, s);
      ctx.restore();
    }

    function drawHeartDepth(hc, zRel){
      const par = clamp(1 - zRel/(H*2.0), 0, 1);
      const rx = hc.x;
      const ry = hc.y;
      const r  = hc.r * (par*0.8+0.2);
      if (heartImg.complete && heartImg.naturalWidth){
        const s = r*2;
        ctx.drawImage(heartImg, rx - s/2, ry - s/2, s, s);
      }else{
        ctx.save();
        ctx.translate(rx, ry);
        ctx.scale(r/12, r/12);
        ctx.fillStyle = '#ff4d6d';
        ctx.beginPath();
        ctx.moveTo(0, 8);
        ctx.bezierCurveTo(12, -6, 8, -14, 0, -6);
        ctx.bezierCurveTo(-8, -14, -12, -6, 0, 8);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawHeartFloating(hc){
      const r = hc.fr;
      if (heartImg.complete && heartImg.naturalWidth){
        const s = r*2;
        ctx.drawImage(heartImg, hc.fx - s/2, hc.fy - s/2, s, s);
      }else{
        ctx.save();
        ctx.translate(hc.fx, hc.fy);
        ctx.scale(r/12, r/12);
        ctx.fillStyle = '#ff4d6d';
        ctx.beginPath();
        ctx.moveTo(0, 8);
        ctx.bezierCurveTo(12, -6, 8, -14, 0, -6);
        ctx.bezierCurveTo(-8, -14, -12, -6, 0, 8);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawShieldDepth(sh){
      const zRel = sh.z - State.world.z;
      const par = clamp(1 - zRel/(H*2.0), 0, 1);
      const rx = sh.x;
      const ry = sh.y;
      const r  = sh.r * (par*0.8+0.2);
      if (shieldImg.complete && shieldImg.naturalWidth){
        const s = r*2;
        ctx.drawImage(shieldImg, rx - s/2, ry - s/2, s, s);
      }else{
        ctx.save();
        ctx.translate(rx, ry);
        ctx.scale(r/12, r/12);
        ctx.fillStyle = '#5ad0ff';
        ctx.beginPath();
        ctx.moveTo(0,-10);
        ctx.lineTo(8,-4);
        ctx.lineTo(6,6);
        ctx.lineTo(0,10);
        ctx.lineTo(-6,6);
        ctx.lineTo(-8,-4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    function drawShieldFloating(sh){
      const r = sh.fr;
      if (shieldImg.complete && shieldImg.naturalWidth){
        const s = r*2;
        ctx.drawImage(shieldImg, sh.fx - s/2, sh.fy - s/2, s, s);
      }else{
        ctx.save();
        ctx.translate(sh.fx, sh.fy);
        ctx.scale(r/12, r/12);
        ctx.fillStyle = '#5ad0ff';
        ctx.beginPath();
        ctx.moveTo(0,-10);
        ctx.lineTo(8,-4);
        ctx.lineTo(6,6);
        ctx.lineTo(0,10);
        ctx.lineTo(-6,6);
        ctx.lineTo(-8,-4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    function maybeSwitchToFloatingPickup(item, zRel){
      if (item.floating || item.got) return;
      if (zRel < 0){
        const par = clamp(1 - zRel/(H*2.0), 0, 1);
        item.fx = item.x;
        item.fy = item.y;
        item.fr = item.r * (par*0.8+0.2);
        item.floating = true;
        item.linger = 1.5;
      }
    }

    function updateFloatingItem(item, dt){
      if (!item.floating || item.got) return;
      item.linger -= dt;
      item.fy += -20 * dt;
      if (item.linger <= 0){
        item.remove = true;
      }
    }

    function spawnCoinBurst(x, y){
      for (let i=0; i<8; i++){
        const ang = Math.random()*Math.PI*2;
        const spd = 60 + Math.random()*80;
        State.fx.particles.push({
          x,
          y,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: 0.2 + Math.random()*0.15,
          t: 0,
          r: 3 + Math.random()*2
        });
      }
    }

    function triggerPulse(){
      State.fx.pulse = State.fx.pulseMax;
    }
    function triggerFlash(){
      State.fx.flash = State.fx.flashMax;
    }

    function checkPickupFloatingCoin(item){
      if (item.got) return;
      const h = State.hero;
      const dx=item.fx-h.x, dy=item.fy-h.y;
      if (dx*dx+dy*dy < (h.r+12)*(h.r+12)){
        item.got=true;
        State.hero.score += 10;
        showToast('+10');
        spawnCoinBurst(h.x, h.y);
      }
    }

    function checkPickupFloatingHeart(item){
      if (item.got) return;
      const h = State.hero;
      const dx=item.fx-h.x, dy=item.fy-h.y;
      if (dx*dx+dy*dy < (h.r+item.fr)*(h.r+item.fr)){
        item.got=true;
        if (h.hp < State.cfg.hpMax){
          h.hp++;
          showToast('ç”Ÿå‘½+1');
        }else{
          State.hero.score += 5;
          showToast('+5ï¼ˆæ»¡è¡€ï¼‰');
        }
        triggerPulse();
        triggerFlash();
      }
    }

    function checkPickupFloatingShield(item){
      if (item.got) return;
      const h = State.hero;
      const dx=item.fx-h.x, dy=item.fy-h.y;
      if (dx*dx+dy*dy < (h.r+item.fr)*(h.r+item.fr)){
        item.got=true;
        h.shieldTime = State.cfg.shieldDuration;
        showToast('æŠ¤ç›¾å·²æ¿€æ´»');
      }
    }

    function update(dt){
      if (!('ontouchstart' in window)) keyboardInput();

      const h = State.hero;
      const w = State.world;
      const cfg = State.cfg;

      State.time.now += dt;
      w.t += dt;
      State.surviveTime += dt;

      // éš¾åº¦éšæ—¶é—´åŠ é€Ÿ
      const targetSpd = cfg.baseSpeed + Math.min(1, State.surviveTime/120) * (cfg.maxSpeed - cfg.baseSpeed);
      w.speed += (targetSpd - w.speed) * 0.2;

      const spdMul = State.input.sprint ? cfg.sprintBoost : 1;
      w.z += w.speed * spdMul * dt * 60;

      // è§’è‰²è¿åŠ¨
      h.vx += State.input.ax * cfg.swimAccel;
      h.vy += State.input.ay * cfg.swimAccel;
      h.vx *= cfg.swimDamp;
      h.vy *= cfg.swimDamp;

      // clamp åˆ° worldPadding å†…éƒ¨
      h.x = clamp(
        h.x + h.vx * dt,
        cfg.worldPadding + h.r,
        W - cfg.worldPadding - h.r
      );
      h.y = clamp(h.y + h.vy * dt, h.r, H - h.r);

      if (h.shieldTime > 0){
        h.shieldTime -= dt;
        if (h.shieldTime < 0) h.shieldTime = 0;
      }

      // ç”Ÿæˆæ°”æ³¡
      if ((State.bubbleTick += dt) > 1/cfg.bubbleRate){
        State.bubbleTick = 0;
        spawnBubble();
      }
      // ç”Ÿæˆéšœç¢
      if ((State.spawnTick  += dt) > cfg.obstacleRate){
        State.spawnTick  = 0;
        spawnObstacle();
      }
      // ç”Ÿæˆé‡‘å¸
      if ((State.coinTick   += dt) > cfg.coinRate){
        State.coinTick   = 0;
        spawnCoin();
      }

      // ç”Ÿæˆå¿ƒ
      State.heartTick += dt;
      const heartInterval = rand(cfg.heartRateRange[0], cfg.heartRateRange[1]);
      if (State.heartTick >= heartInterval){
        const baseP = 0.18;
        const bonus = Math.min(0.10, State.surviveTime / 180 * 0.10);
        if (Math.random() < baseP + bonus){
          spawnHeart();
        }
        State.heartTick = 0;
      }

      // ç”ŸæˆæŠ¤ç›¾
      State.shieldTick += dt;
      const shieldInterval = rand(cfg.shieldRateRange[0], cfg.shieldRateRange[1]);
      if (State.shieldTick >= shieldInterval){
        const baseSP = 0.25;
        const bonusS = Math.min(0.12, State.surviveTime / 180 * 0.12);
        if (Math.random() < baseSP + bonusS){
          spawnShield();
        }
        State.shieldTick = 0;
      }

      // æ°”æ³¡ä¸Šæµ®è¡°å‡
      for (let i=State.bubbles.length-1;i>=0;i--){
        const b=State.bubbles[i];
        b.life -= dt;
        b.y += -40*dt;
        if (b.life<=0) State.bubbles.splice(i,1);
      }

      // éšœç¢æ£€æµ‹
      for (let i=State.obs.length-1;i>=0;i--){
        const o=State.obs[i];
        const zRel = o.z - w.z;
        if (zRel < -40){
          State.obs.splice(i,1);
          continue;
        }
        if (!o.hit && Math.abs(zRel) < 40){
          if (aabbCircleOverlap(o.x - o.w/2, o.y - o.h/2, o.w, o.h, h.x, h.y, h.r)){
            o.hit=true;
            onHit();
          }
        }
      }

      // é‡‘å¸
      for (let i=State.coins.length-1;i>=0;i--){
        const c=State.coins[i];
        if (!c.floating){
          const zRel = c.z - w.z;
          maybeSwitchToFloatingPickup(c, zRel);
          if (!c.floating && zRel < -20){
            State.coins.splice(i,1);
            continue;
          }
          if (!c.got && !c.floating && Math.abs(zRel) < 40){
            const dx=c.x-h.x, dy=c.y-h.y;
            if (dx*dx+dy*dy < (h.r+12)*(h.r+12)){
              c.got=true;
              State.hero.score += 10;
              showToast('+10');
              spawnCoinBurst(h.x, h.y);
            }
          }
        }else{
          updateFloatingItem(c, dt);
          checkPickupFloatingCoin(c);
          if (c.remove || c.got){
            State.coins.splice(i,1);
            continue;
          }
        }
      }

      // çˆ±å¿ƒ
      for (let i=State.hearts.length-1;i>=0;i--){
        const hc=State.hearts[i];
        if (!hc.floating){
          const zRel = hc.z - w.z;
          maybeSwitchToFloatingPickup(hc, zRel);
          if (!hc.floating && zRel < -20){
            State.hearts.splice(i,1);
            continue;
          }
          if (!hc.got && !hc.floating && Math.abs(zRel) < 40){
            const dx=hc.x-h.x, dy=hc.y-h.y;
            if (dx*dx+dy*dy < (h.r+hc.r)*(h.r+hc.r)){
              hc.got=true;
              if (h.hp < cfg.hpMax){
                h.hp++;
                showToast('ç”Ÿå‘½+1');
              }else{
                State.hero.score += 5;
                showToast('+5ï¼ˆæ»¡è¡€ï¼‰');
              }
              triggerPulse();
              triggerFlash();
            }
          }
        }else{
          updateFloatingItem(hc, dt);
          checkPickupFloatingHeart(hc);
          if (hc.remove || hc.got){
            State.hearts.splice(i,1);
            continue;
          }
        }
      }

      // æŠ¤ç›¾
      for (let i=State.shields.length-1;i>=0;i--){
        const sh=State.shields[i];
        if (!sh.floating){
          const zRel = sh.z - w.z;
          maybeSwitchToFloatingPickup(sh, zRel);
          if (!sh.floating && zRel < -20){
            State.shields.splice(i,1);
            continue;
          }
          if (!sh.got && !sh.floating && Math.abs(zRel) < 40){
            const dx=sh.x-h.x, dy=sh.y-h.y;
            if (dx*dx+dy*dy < (h.r+sh.r)*(h.r+sh.r)){
              sh.got=true;
              h.shieldTime = cfg.shieldDuration;
              showToast('æŠ¤ç›¾å·²æ¿€æ´»');
            }
          }
        }else{
          updateFloatingItem(sh, dt);
          checkPickupFloatingShield(sh);
          if (sh.remove || sh.got){
            State.shields.splice(i,1);
            continue;
          }
        }
      }

      // å—ä¼¤åæ— æ•Œè®¡æ—¶
      h.invul = Math.max(0, h.invul - dt);

      // ç²’å­æ›´æ–°
      for (let i = State.fx.particles.length-1; i>=0; i--){
        const p = State.fx.particles[i];
        p.t += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.t >= p.life){
          State.fx.particles.splice(i,1);
        }
      }

      // å¿ƒè·³è„‰å†²ã€é—ªå…‰è¡°å‡
      if (State.fx.pulse > 0){
        State.fx.pulse -= dt;
        if (State.fx.pulse < 0) State.fx.pulse = 0;
      }
      if (State.fx.flash > 0){
        State.fx.flash -= dt;
        if (State.fx.flash < 0) State.fx.flash = 0;
      }

      // HUD
      scoreEl.textContent = Math.floor(h.score);
      spdEl.textContent = w.speed.toFixed(1);
      hpEl.textContent = h.hp;

      // åŸºç¡€åˆ†éšæ—¶é—´å¢åŠ 
      h.score += dt * w.speed * (State.input.sprint?1.0:0.7);

      // éœ‡å±è¡°å‡
      if (State.shake.t > 0){
        State.shake.t -= dt;
        if (State.shake.t < 0) State.shake.t = 0;
      }
    }

    function onHit(){
      const h=State.hero;
      if (h.shieldTime > 0){
        h.shieldTime = 0;
        h.invul = State.cfg.hurtCooldown * 0.5;
        State.shake.t = 0.2;
        State.shake.mag = 4;
        showToast('æŠ¤ç›¾æŠµæŒ¡!');
        return;
      }
      if (h.invul>0) return;

      h.hp -= State.cfg.damage;
      h.invul = State.cfg.hurtCooldown;
      State.shake.t = 0.25;
      State.shake.mag = 5;
      showToast(h.hp>0 ? '-HP' : 'ä½ è¢«å‡»å€’äº†');

      if (h.hp <= 0){
        gameOver();
      }
    }

    function gameOver(){
      State.running=false;
      State.paused=false;
      pauseOverlay.style.display='none';

      saveScore(State.runDifficulty, State.hero.score);

      panelTitleEl.textContent='Game Over Â· å†æ¥ä¸€æŠŠï¼Ÿ';
      panelDescEl.innerHTML='ä½ è¢«å‡»å€’äº†ã€‚å¯ä»¥ç›´æ¥é‡æ–°å¼€å§‹ï¼Œæˆ–ç‚¹å³ä¸‹è§’â€œé‡å¼€â€å›åˆ°ä¸»èœå•é‡æ–°è°ƒéš¾åº¦ã€‚';
      startBtn.textContent='é‡æ–°å¼€å§‹';
      renderLeaderboardPanel();
      panel.style.display='block';

      State.time.last = 0;
    }

    function goToMenu(){
      State.running=false;
      State.paused=false;
      pauseOverlay.style.display='none';

      panelTitleEl.innerHTML='<span>Gyro Swim Runner Â· æ¸¸æ³³é™€èºä»ªè·‘é…·</span>';
      panelDescEl.innerHTML='æŒ‰<strong>å¼€å§‹</strong>åï¼Œè‹¥æ˜¯ iOS è®¾å¤‡ä¼šå¼¹å‡ºâ€œå…è®¸è¿åŠ¨è®¿é—®â€çš„å¯¹è¯æ¡†ï¼Œè¯·é€‰æ‹©å…è®¸ã€‚<br>å·¦å³å€¾æ–œæ§åˆ¶æ°´å¹³ç§»åŠ¨ï¼›å‰åå€¾æ–œæ§åˆ¶ä¸Š/ä¸‹æµ®ï¼›é•¿æŒ‰å±å¹•å†²åˆºã€‚';
      startBtn.textContent='å¼€å§‹æ¸¸æˆ';
      renderLeaderboardPanel();
      panel.style.display='block';

      State.time.last = 0;
    }

    function start(){
      State.reset();
      State.running=true;
      State.paused=false;
      State.time.last=0;
      panel.style.display='none';
      showToast('å·¦å³å€¾æ–œç§»åŠ¨ï¼Œé•¿æŒ‰å†²åˆº');
    }

    function restart(){
      goToMenu();
    }

    function togglePause(){
      if (!State.running) return;
      State.paused=!State.paused;
      pauseOverlay.style.display = State.paused?'grid':'none';
    }

    let rafId=0;
    function loop(){
      rafId = requestAnimationFrame(loop);
      if (!State.running || State.paused) return;

      const now=performance.now();
      if (!State.time.last) State.time.last=now;
      const dt = clamp((now - State.time.last)/1000, 0, 0.05);
      State.time.last=now;

      update(dt);

      ctx.save();

      // å±å¹•æŠ–åŠ¨
      if (State.shake.t > 0){
        const decay = State.shake.t / 0.25;
        const magNow = State.shake.mag * decay;
        const sx = (Math.random()*2-1) * magNow;
        const sy = (Math.random()*2-1) * magNow;
        ctx.translate(sx, sy);
      }

      clearFrame();

      // ç”»èƒŒæ™¯æ³¡æ³¡
      for (const b of State.bubbles){
        ctx.globalAlpha=0.35;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fillStyle='#7fdcff';
        ctx.fill();
        ctx.globalAlpha=1;
      }

      // é‡‘å¸ï¼ˆä¸¤ç§çŠ¶æ€ï¼šæ·±åº¦ or é£˜æµ®ï¼‰
      for (const c of State.coins){
        if (!c.floating){
          const zRel = c.z - State.world.z;
          drawCoinDepth(c, zRel);
        }else{
          drawCoinFloating(c);
        }
      }

      // éšœç¢ç‰©ï¼ˆé²¨é±¼/å‰‘é±¼ï¼Œå¸¦éšæœºæœå‘ï¼‰
      for (const o of State.obs){
        drawObstacle(o, o.z - State.world.z);
      }

      // çˆ±å¿ƒ
      for (const hc of State.hearts){
        if (!hc.floating){
          const zRel = hc.z - State.world.z;
          drawHeartDepth(hc, zRel);
        }else{
          drawHeartFloating(hc);
        }
      }

      // æŠ¤ç›¾
      for (const sh of State.shields){
        if (!sh.floating){
          drawShieldDepth(sh);
        }else{
          drawShieldFloating(sh);
        }
      }

      // è·å¾—çˆ±å¿ƒ/å—å‡»æ—¶çš„ç²‰è‰²è„‰å†²åœˆ
      if (State.fx.pulse > 0){
        const h = State.hero;
        const k = 1 - (State.fx.pulse / State.fx.pulseMax);
        const radius = 50 + k * (150-50);
        const alpha  = 0.4 * (1 - k);
        ctx.save();
        ctx.globalAlpha = alpha;
        const grd = ctx.createRadialGradient(h.x, h.y, 0, h.x, h.y, radius);
        grd.addColorStop(0, 'rgba(255,120,160,1)');
        grd.addColorStop(1, 'rgba(255,120,160,0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(h.x, h.y, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // ä¸»è§’
      drawHero(State.hero, State.world.t);

      // é‡‘å¸çˆ†è£‚çš„é‡‘è‰²å°ç²’å­
      for (const p of State.fx.particles){
        const lifeK = 1 - (p.t / p.life);
        ctx.save();
        ctx.globalAlpha = lifeK;
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r*2);
        grad.addColorStop(0, 'rgba(255,230,150,1)');
        grad.addColorStop(1, 'rgba(255,230,150,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r*2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // çº¢ç²‰è‰²é—ªå±
      if (State.fx.flash > 0){
        const k = 1 - (State.fx.flash / State.fx.flashMax);
        const alpha = 0.2 * (1 - k);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#ff99bb';
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      ctx.restore();
    }

    startBtn.addEventListener('click', ()=>{
      requestMotionPermission();
      start();
    }, {passive:true});

    pauseBtn.addEventListener('click', ()=> togglePause());
    resumeBtn.addEventListener('click', ()=> togglePause());
    restartBtn.addEventListener('click', ()=> {
      restart();
    });

    calBtn.addEventListener('click', ()=>{
      calibrate();
      const oldText = calBtn.textContent;
      calBtn.textContent = 'å·²æ ¡å‡† âœ…';
      setTimeout(()=>{ calBtn.textContent = oldText; }, 1200);
    });

    sensSlider.addEventListener('input', ()=>{
      State.device.sens = parseFloat(sensSlider.value);
    });

    diffSel.addEventListener('change', ()=>{
      showToast('éš¾åº¦ï¼š'+diffSel.value);
    });

    renderLeaderboardPanel();
    loop();
  })();
  </script>
</body>
</html>
